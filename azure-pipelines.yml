# Azure DevOps Pipeline für MthBdeIotClient
# Automatisierte Builds und GitHub Releases

trigger:
  branches:
    include:
      - master
      - release/*
  tags:
    include:
      - "v*"

variables:
  # Build-Konfiguration
  buildConfiguration: "Release"
  nodeVersion: "22.x"

  # Versioning
  isRelease: $[startsWith(variables['Build.SourceBranch'], 'refs/tags/v')]
  releaseVersion: $[replace(variables['Build.SourceBranchName'], 'v', '')]

  # GitHub Repository Info
  githubRepository: "mthitservice/MTHBDEIOTClient"
  githubConnection: "github-connection" # Service Connection Name

  # Artifact Names
  artifactName: "MthBdeIotClient-Release"

stages:
  - stage: Build
    displayName: "Build Application"
    jobs:
      - job: BuildElectronApp
        displayName: "Build Electron Application"
        pool:
          vmImage: "ubuntu-latest"

        steps:
          - checkout: self
            fetchDepth: 0
            persistCredentials: true

          - task: NodeTool@0
            displayName: "Install Node.js"
            inputs:
              versionSpec: $(nodeVersion)

          - task: Cache@2
            displayName: "Cache node modules"
            inputs:
              key: 'npm | "$(Agent.OS)" | App/package-lock.json'
              restoreKeys: |
                npm | "$(Agent.OS)"
              path: App/node_modules

          - script: |
              cd App
              # Vollständige Installation mit allen DevDependencies
              npm ci --engine-strict=false || npm install --engine-strict=false

              # Alle notwendigen DevDependencies explizit installieren
              npm install --save-dev \
                webpack@^5.96.1 \
                webpack-cli@^5.1.4 \
                ts-node@^10.9.2 \
                typescript@^5.6.3 \
                electron@^35.0.2 \
                electron-builder@^26.0.12 \
                chalk@^4.1.2 \
                cross-env@^7.0.3 \
                concurrently@^9.1.2 \
                rimraf@^3.0.2

              # Verify essential tools are available
              echo "Verifying installed tools..."
              npx --version
              npx ts-node --version || echo "ts-node not available"
              npx concurrently --version || echo "concurrently not available"
              npx electron-builder --version || echo "electron-builder not available"

              echo "All dependencies installed successfully"
            displayName: "Install dependencies"

          - script: |
              # Version aus Tag oder automatisch generieren
              if [ "$ISRELEASE" = "True" ]; then
                VERSION="$RELEASEVERSION"
                echo "Release Version: $VERSION"
              else
                BUILD_NUMBER="$BUILD_BUILDNUMBER"
                SHORT_COMMIT=$(echo "$BUILD_SOURCEVERSION" | cut -c1-7)
                VERSION="1.0.0-dev.$BUILD_NUMBER+$SHORT_COMMIT"
                echo "Development Version: $VERSION"
              fi

              # Environment Variables setzen
              echo "##vso[task.setvariable variable=APP_VERSION]$VERSION"
              echo "##vso[task.setvariable variable=NODE_ENV]production"
              echo "##vso[task.setvariable variable=REACT_APP_VERSION]$VERSION"
              echo "##vso[task.setvariable variable=ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES]true"

              # Package.json Version aktualisieren mit Node.js
              cd App
              node -e "
                const fs = require('fs');
                const path = 'package.json';
                try {
                  const packageJson = JSON.parse(fs.readFileSync(path, 'utf8'));
                  packageJson.version = '$VERSION';
                  fs.writeFileSync(path, JSON.stringify(packageJson, null, 2));
                  console.log('Updated package.json version to: $VERSION');
                } catch (error) {
                  console.log('Warning: Could not update package.json version:', error.message);
                }
              "
            displayName: "Set Version and Environment Variables (Bash)"

          - script: |
              cd App
              # Environment Variables für Build setzen
              export NODE_ENV=production
              export APP_VERSION=$(APP_VERSION)
              export REACT_APP_VERSION=$(APP_VERSION)
              export ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES=true

              # Build mit direkten webpack calls falls npm scripts nicht funktionieren
              echo "Building application using direct webpack calls..."

              # Main process build
              echo "Building main process..."
              npx cross-env NODE_ENV=production TS_NODE_TRANSPILE_ONLY=true NODE_OPTIONS="-r ts-node/register --no-warnings" webpack --config ./.erb/configs/webpack.config.main.prod.ts

              # Renderer process build
              echo "Building renderer process..."
              npx cross-env NODE_ENV=production TS_NODE_TRANSPILE_ONLY=true NODE_OPTIONS="-r ts-node/register --no-warnings" webpack --config ./.erb/configs/webpack.config.renderer.prod.ts

              # Fallback: Try npm scripts
              echo "Attempting npm scripts as fallback..."
              npm run build || echo "npm run build failed, using direct webpack builds"

              echo "Build completed successfully"
            displayName: "Build Application"
            env:
              NODE_ENV: production
              APP_VERSION: $(APP_VERSION)
              REACT_APP_VERSION: $(APP_VERSION)
              ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES: true

          - script: |
              cd App
              # Electron Builder - robuste Packaging-Strategie
              echo "Starting Electron packaging with robust approach..."

              # Clean the dist folder first
              echo "Cleaning previous builds..."
              rm -rf dist || echo "No dist folder to clean"
              rm -rf release || echo "No release folder to clean"

              # Ensure build is complete
              echo "Ensuring build is complete..."
              
              # Try npm scripts first, then fallback to direct electron-builder
              echo "Attempting npm packaging scripts..."
              npm run package:all || {
                echo "npm scripts failed, trying direct electron-builder..."
                
                # Build DLL first
                npx cross-env NODE_ENV=development TS_NODE_TRANSPILE_ONLY=true NODE_OPTIONS="-r ts-node/register --no-warnings" webpack --config ./.erb/configs/webpack.config.renderer.dev.dll.ts || echo "DLL build failed"
                
                # Direct electron-builder calls
                echo "Using direct electron-builder calls..."
                npx electron-builder build --publish never --win --linux --mac || echo "Cross-platform build failed"
              }

              echo "Creating Raspberry Pi specific builds..."
              npm run package:raspberry || npx electron-builder build --linux tar.gz --armv7l --publish never --config.nodeGypRebuild=false || echo "Raspberry Pi tar.gz build failed"
              npm run package:raspberry-deb || npx electron-builder build --linux deb --armv7l --publish never --config.nodeGypRebuild=false || echo "Raspberry Pi deb build failed"

              # List what was actually created
              echo "=== Checking what was built ==="
              find . -name "*.exe" -o -name "*.deb" -o -name "*.tar.gz" -o -name "*.dmg" -o -name "*.appx" -o -name "*.snap" -o -name "*.AppImage" | head -20

              # Also check the dist folder structure
              echo "=== Dist folder structure ==="
              if [ -d "dist" ]; then
                find dist -type f | head -20
              else
                echo "No dist folder found"
              fi

              # Check release folder structure
              echo "=== Release folder structure ==="
              if [ -d "release" ]; then
                find release -type f | head -20
              else
                echo "No release folder found"
              fi

              echo "Packaging phase completed"
            displayName: "Package Electron App"
            env:
              NODE_ENV: production
              APP_VERSION: $(APP_VERSION)
              REACT_APP_VERSION: $(APP_VERSION)
              GH_TOKEN: $(GITHUB_TOKEN)
              ELECTRON_BUILDER_ALLOW_UNRESOLVED_DEPENDENCIES: true
            continueOnError: true

          - task: CopyFiles@2
            displayName: "Copy Build Artifacts (Release)"
            inputs:
              sourceFolder: "App/release"
              contents: "**/*"
              targetFolder: "$(Build.ArtifactStagingDirectory)/release"
              cleanTargetFolder: true
            condition: succeededOrFailed()

          - task: CopyFiles@2
            displayName: "Copy Build Artifacts (Dist)"
            inputs:
              sourceFolder: "App/dist"
              contents: "**/*"
              targetFolder: "$(Build.ArtifactStagingDirectory)/dist"
            condition: succeededOrFailed()

          - script: |
              echo "=== Debugging Release Structure ==="
              find App/release -type f 2>/dev/null | head -30 || echo "No release directory found"

              echo "=== Debugging Dist Structure ==="
              find App/dist -type f 2>/dev/null | head -30 || echo "No dist directory found"

              echo "=== Specific release files ==="
              find App/release -type f \( -name "*.exe" -o -name "*.deb" -o -name "*.tar.gz" -o -name "*.AppImage" -o -name "*.dmg" \) 2>/dev/null || echo "No release files found"

              echo "=== Staging Directory Contents ==="
              ls -la $(Build.ArtifactStagingDirectory)/ 2>/dev/null || echo "Staging directory empty"

              echo "=== Staging subdirectories ==="
              find $(Build.ArtifactStagingDirectory) -type f 2>/dev/null | head -20 || echo "No files in staging"
            displayName: "Debug Release Files"
            condition: succeededOrFailed()

          - task: CopyFiles@2
            displayName: "Copy Installation Scripts"
            inputs:
              sourceFolder: "App"
              contents: |
                RASPBERRY_INSTALLATION.md
                deploy.ps1
                generate-inventory.sh
                Dockerfile.raspberry
              targetFolder: "$(Build.ArtifactStagingDirectory)/installation"

          - task: PublishBuildArtifacts@1
            displayName: "Publish Build Artifacts"
            inputs:
              pathToPublish: "$(Build.ArtifactStagingDirectory)"
              artifactName: $(artifactName)
              publishLocation: "Container"
            condition: always()

          - script: |
              echo "=== Final check: What was actually published? ==="
              ls -la $(Build.ArtifactStagingDirectory)/ 2>/dev/null || echo "Nothing in staging directory"

              echo "=== Size of staging directory ==="
              du -sh $(Build.ArtifactStagingDirectory)/ 2>/dev/null || echo "Cannot measure size"

              echo "=== All files that would be published ==="
              find $(Build.ArtifactStagingDirectory) -type f | wc -l 2>/dev/null || echo "Cannot count files"
            displayName: "Final Artifact Check"
            condition: always()
  - stage: Release
    displayName: "GitHub Release"
    condition: and(succeeded(), eq(variables.isRelease, true))
    dependsOn: Build
    jobs:
      - deployment: GitHubRelease
        displayName: "Create GitHub Release"
        environment: "Production"
        pool:
          vmImage: "ubuntu-latest"
        strategy:
          runOnce:
            deploy:
              steps:
                - script: |
                    echo "=== Checking available artifacts ==="
                    echo "Build ID: $(Build.BuildId)"
                    echo "Build Number: $(Build.BuildNumber)"
                    echo "Artifact Name: $(artifactName)"
                  displayName: "Check Build Information"

                - download: current
                  displayName: "Try to download artifacts"
                  continueOnError: true

                - script: |
                    echo "=== Pipeline Workspace Structure ==="
                    ls -la $(Pipeline.Workspace)/ || echo "Pipeline workspace not found"

                    echo "=== Available artifacts ==="
                    find $(Pipeline.Workspace) -name "*" -type d | head -10 || echo "No directories found"

                    echo "=== All files ==="
                    find $(Pipeline.Workspace) -type f | head -20 || echo "No files found"
                  displayName: "Debug Available Files"

                - task: PowerShell@2
                  displayName: "Prepare Release Notes"
                  inputs:
                    targetType: "inline"
                    script: |
                      $version = "$(releaseVersion)"
                      $buildNumber = "$(Build.BuildNumber)"
                      $sourceVersion = "$(Build.SourceVersion)"
                      $releaseNotes = @"
                      # MthBdeIotClient Release $version

                      ## 🚀 Neue Features und Verbesserungen

                      ### 📦 Verfügbare Downloads:
                      - **Windows:** `MthBdeIotClient-Setup-$version.exe`
                      - **Raspberry Pi 3+ (ARMv7l):** `mthbdeiotclient_$version_armhf.deb`
                      - **Raspberry Pi (tar.gz):** `MthBdeIotClient-$version-linux-armv7l.tar.gz`

                      ### 🔧 Installation:

                      #### Windows:
                      ```bash
                      # Download und Installation
                      ./MthBdeIotClient-Setup-$version.exe
                      ```

                      #### Raspberry Pi:
                      ```bash
                      # .deb Installation
                      sudo dpkg -i mthbdeiotclient_$version_armhf.deb
                      sudo apt-get install -f

                      # Oder tar.gz
                      tar -xzf MthBdeIotClient-$version-linux-armv7l.tar.gz
                      ```

                      ### 📋 Automatische Raspberry Pi Installation:
                      Siehe [RASPBERRY_INSTALLATION.md](./RASPBERRY_INSTALLATION.md) für detaillierte Ansible-Deployment Anweisungen.

                      ### 🔗 Schnell-Installation:
                      ```bash
                      # Direkter Download und Installation (Raspberry Pi)
                      curl -L https://github.com/$(githubRepository)/releases/download/v$version/mthbdeiotclient_$version_armhf.deb -o mthbdeiotclient.deb
                      sudo dpkg -i mthbdeiotclient.deb
                      sudo apt-get install -f
                      ```

                      ---
                      **Build:** $buildNumber
                      **Commit:** $sourceVersion
                      **Status:** Build erfolgreich, aber electron-builder hat keine Installationspakete erstellt
                      "@

                      $releaseNotes | Out-File -FilePath "$(Agent.TempDirectory)/release-notes.md" -Encoding UTF8
                      Write-Host "Release notes prepared for version $version"

                - task: GitHubRelease@1
                  displayName: "Delete existing GitHub Release (if exists)"
                  condition: always()
                  inputs:
                    gitHubConnection: $(githubConnection)
                    repositoryName: $(githubRepository)
                    action: "delete"
                    tag: "v$(releaseVersion)"
                  continueOnError: true

                - task: GitHubRelease@1
                  displayName: "Create GitHub Release"
                  condition: always()
                  inputs:
                    gitHubConnection: $(githubConnection)
                    repositoryName: $(githubRepository)
                    action: "create"
                    target: "$(Build.SourceVersion)"
                    tagSource: "userSpecifiedTag"
                    tag: "v$(releaseVersion)"
                    title: "MthBdeIotClient v$(releaseVersion)"
                    releaseNotesFilePath: "$(Agent.TempDirectory)/release-notes.md"
                    assets: |
                      $(Pipeline.Workspace)/MthBdeIotClient-Release/installation/*
                      $(Pipeline.Workspace)/MthBdeIotClient-Release/release/**/*
                      $(Pipeline.Workspace)/MthBdeIotClient-Release/dist/**/*
                    assetUploadMode: "replace"
                    isDraft: true
                    isPreRelease: false
                    addChangeLog: false
                  continueOnError: true

  - stage: UpdateLatest
    displayName: "Update Latest Release"
    condition: and(succeeded(), eq(variables.isRelease, true))
    dependsOn: Release
    jobs:
      - job: UpdateLatestTag
        displayName: "Update Latest Tag"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self
            fetchDepth: 0
            persistCredentials: true

          - task: PowerShell@2
            displayName: "Update Latest Tag"
            inputs:
              targetType: "inline"
              script: |
                # Git konfigurieren
                git config user.name "Azure DevOps"
                git config user.email "devops@mth-it-service.com"

                # Latest Tag auf aktuellen Release setzen
                $version = "$(releaseVersion)"
                Write-Host "Updating latest tag to version: $version"

                # Bestehenden latest Tag löschen (lokal und remote)
                git tag -d latest 2>$null || true
                git push origin --delete latest 2>$null || true

                # Neuen latest Tag erstellen
                git tag latest
                git push origin latest

                Write-Host "Latest tag updated successfully"
            env:
              SYSTEM_ACCESSTOKEN: $(System.AccessToken)

  - stage: Documentation
    displayName: "Update Documentation"
    condition: and(succeeded(), eq(variables.isRelease, true))
    dependsOn: Release
    jobs:
      - job: UpdateDocs
        displayName: "Update Installation Documentation"
        pool:
          vmImage: "ubuntu-latest"
        steps:
          - checkout: self
            fetchDepth: 0
            persistCredentials: true

          - task: PowerShell@2
            displayName: "Update Installation Links"
            inputs:
              targetType: "inline"
              script: |
                $version = "$(releaseVersion)"
                $repoUrl = "https://github.com/$(githubRepository)"

                # README.md Update mit aktuellen Download-Links
                $readmePath = "README.md"
                if (Test-Path $readmePath) {
                  $content = Get-Content $readmePath -Raw

                  # Update Download-Badges
                  $content = $content -replace 'download/v[\d\.]+/', "download/v$version/"
                  $content = $content -replace 'releases/latest/', "releases/download/v$version/"

                  Set-Content $readmePath $content
                }

                # RASPBERRY_INSTALLATION.md Update
                $installPath = "App/RASPBERRY_INSTALLATION.md"
                if (Test-Path $installPath) {
                  $content = Get-Content $installPath -Raw

                  # Update Download-URLs
                  $content = $content -replace 'releases/download/v[\d\.]+/', "releases/download/v$version/"
                  $content = $content -replace 'mthbdeiotclient_[\d\.]+_armhf\.deb', "mthbdeiotclient_$version`_armhf.deb"

                  Set-Content $installPath $content
                }

                Write-Host "Documentation updated with version $version"
